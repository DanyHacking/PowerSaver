"""
Smart Contract Vulnerability Scanner
Detects common vulnerabilities in Solidity smart contracts
"""

import re
import asyncio
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class VulnerabilityLevel(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class Vulnerability:
    name: str
    description: str
    level: VulnerabilityLevel
    line_number: int
    code_snippet: str
    recommendation: str
    cwe_id: Optional[str] = None


@dataclass
class ScanResult:
    contract_address: str
    contract_name: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scan_time: float = 0.0
    lines_of_code: int = 0
    
    @property
    def is_safe(self) -> bool:
        return len([v for v in self.vulnerabilities if v.level in [VulnerabilityLevel.CRITICAL, VulnerabilityLevel.HIGH]]) == 0
    
    @property
    def critical_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.level == VulnerabilityLevel.CRITICAL])
    
    @property
    def high_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.level == VulnerabilityLevel.HIGH])


class VulnerabilityScanner:
    """Main vulnerability scanner class"""
    
    VULNERABILITY_PATTERNS = {
        "reentrancy": {
            "pattern": r"(?<!nonReentrant\.)(?<!\w)(call|send|transfer)\s*\(",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-367",
            "description": "Reentrancy vulnerability - external call before state change",
            "recommendation": "Use checks-effects-interactions pattern or ReentrancyGuard"
        },
        "unprotected_eth_withdrawal": {
            "pattern": r"selfdestruct|payable\s*\(\s*address\s*\(\s*0\s*\)\s*\)",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-451",
            "description": "Unprotected Ether withdrawal",
            "recommendation": "Add access control to selfdestruct functions"
        },
        "uninitialized_storage_pointer": {
            "pattern": r"struct\s+\w+\s*\{[^}]*\}\s*;",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-119",
            "description": "Uninitialized storage pointer",
            "recommendation": "Always initialize struct variables before use"
        },
        "tx_origin_usage": {
            "pattern": r"\btx\.origin\b",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-477",
            "description": "tx.origin usage for authorization",
            "recommendation": "Use msg.sender instead of tx.origin"
        },
        "unchecked_call_return": {
            "pattern": r"(?:call|send|transfer)\s*\([^)]*\)\s*;(?!\s*require)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-252",
            "description": "Unchecked return value from external call",
            "recommendation": "Always check return value or use SafeERC20"
        },
        "integer_overflow": {
            "pattern": r"\+\+|\+=|-=|\*=|/=",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-190",
            "description": "Potential integer overflow/underflow",
            "recommendation": "Use Solidity 0.8+ or SafeMath"
        },
        "unlocked_prng": {
            "pattern": r"block\.hash\s*\(\s*block\.number\s*-\s*1\s*\)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-338",
            "description": "Predictable random number (front-runnable)",
            "recommendation": "Use Chainlink VRF or other randomness oracle"
        },
        "access_control_missing": {
            "pattern": r"function\s+\w+\s*\([^)]*\)\s*(?:public|external)\s*\{(?!.*require.*owner|.*if.*owner|.*onlyOwner)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-862",
            "description": "Missing access control on sensitive function",
            "recommendation": "Add require(msg.sender == owner) or use Ownable"
        },
        "front_running": {
            "pattern": r"require\s*\(\s*msg\.value\s*>=",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-346",
            "description": "Potential front-running vulnerability",
            "recommendation": "Use commit-reveal scheme or batch auctions"
        },
        "dos_external_call": {
            "pattern": r"\.call\s*\(\s*[\"']{1,2}[\"']{1,2}\s*\)",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-400",
            "description": "Denial of Service via external call",
            "recommendation": "Avoid arbitrary call in loop"
        },
        "dangerous_abi_encode": {
            "pattern": r"abi\.encodePacked\s*\([^)]*\)",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-327",
            "description": "Potential hash collision with abi.encodePacked",
            "recommendation": "Use abi.encode instead for type safety"
        },
        "block_timestamp": {
            "pattern": r"block\.timestamp",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-382",
            "description": "Dependence on block timestamp",
            "recommendation": "Don't use block.timestamp for critical logic"
        },
        "hardcoded_address": {
            "pattern": r"0x[0-9a-fA-F]{40}",
            "level": VulnerabilityLevel.LOW,
            "cwe": "CWE-259",
            "description": "Hardcoded contract address",
            "recommendation": "Use constructor parameters or configuration"
        },
    }

    def __init__(self, web3=None):
        self.web3 = web3
        self.abi_cache: Dict[str, str] = {}
        
    async def scan_source_code(self, source_code: str, contract_name: str = "Unknown") -> ScanResult:
        """Scan Solidity source code for vulnerabilities"""
        import time
        start_time = time.time()
        
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for vuln_name, vuln_info in self.VULNERABILITY_PATTERNS.items():
            pattern = vuln_info["pattern"]
            level = vuln_info["level"]
            description = vuln_info["description"]
            recommendation = vuln_info["recommendation"]
            cwe = vuln_info.get("cwe")
            
            for line_num, line in enumerate(lines, 1):
                if re.search(pattern, line, re.MULTILINE | re.IGNORECASE):
                    if self._is_false_positive(vuln_name, line):
                        continue
                    vulnerabilities.append(Vulnerability(
                        name=vuln_name,
                        description=description,
                        level=level,
                        line_number=line_num,
                        code_snippet=line.strip()[:100],
                        recommendation=recommendation,
                        cwe_id=cwe
                    ))
        
        vulnerabilities.extend(self._check_solidity_version(lines))
        
        scan_time = time.time() - start_time
        
        return ScanResult(
            contract_address="",
            contract_name=contract_name,
            vulnerabilities=vulnerabilities,
            scan_time=scan_time,
            lines_of_code=len(lines)
        )
    
    async def scan_bytecode_analysis(self, address: str) -> ScanResult:
        """Basic bytecode analysis"""
        return ScanResult(
            contract_address=address,
            contract_name="Bytecode Analysis",
            vulnerabilities=[]
        )
    
    def _is_false_positive(self, vuln_name: str, line: str) -> bool:
        if line.strip().startswith("//"):
            return True
        if "event" in line.lower() and "emit" in line.lower():
            return True
        if vuln_name == "integer_overflow":
            if "require" in line or "assert" in line:
                return True
        return False
    
    def _check_solidity_version(self, lines: List[str]) -> List[Vulnerability]:
        vulnerabilities = []
        for line_num, line in enumerate(lines, 1):
            if "pragma solidity" in line:
                if re.search(r"pragma\s+solidity\s+\^?0\.[0-7]\.", line, re.IGNORECASE):
                    vulnerabilities.append(Vulnerability(
                        name="outdated_solidity_version",
                        description="Using outdated Solidity version (< 0.8.0)",
                        level=VulnerabilityLevel.HIGH,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation="Upgrade to Solidity 0.8.0+"
                    ))
        return vulnerabilities
    
    def generate_report(self, result: ScanResult) -> str:
        report = []
        report.append("=" * 60)
        report.append(f"SECURITY SCAN REPORT: {result.contract_name}")
        report.append("=" * 60)
        report.append(f"Lines of Code: {result.lines_of_code}")
        report.append(f"Scan Time: {result.scan_time:.2f}s")
        report.append("")
        if result.is_safe:
            report.append("✅ RESULT: NO CRITICAL VULNERABILITIES FOUND")
        else:
            report.append("⚠️  RESULT: VULNERABILITIES DETECTED")
        return "\n".join(report)


class ContractSecurityValidator:
    def __init__(self, web3=None):
        self.scanner = VulnerabilityScanner(web3)
        self.whitelist: Dict[str, bool] = {}
        self.verified_contracts: set = set()
        
    async def validate_contract(self, address: str, source_code: str = None) -> Tuple[bool, ScanResult]:
        if address in self.verified_contracts:
            return True, None
        if address in self.whitelist and self.whitelist[address]:
            return True, None
        result = await self.scanner.scan_source_code(source_code or "")
        if result.is_safe:
            self.whitelist[address] = True
            self.verified_contracts.add(address)
            logger.info(f"Contract {address} validated")
            return True, result
        logger.warning(f"Contract {address} has vulnerabilities")
        return False, result
    
    def is_approved(self, address: str) -> bool:
        return address in self.verified_contracts
    
    def add_to_whitelist(self, address: str):
        self.whitelist[address] = True
        self.verified_contracts.add(address)
