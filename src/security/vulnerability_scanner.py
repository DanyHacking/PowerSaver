"""
Smart Contract Vulnerability Scanner - Enhanced Version
Detects ALL major vulnerability categories in Solidity smart contracts
"""

import re
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class VulnerabilityLevel(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class VulnerabilityCategory(Enum):
    ACCESS_CONTROL = "Access Control"
    REENTRANCY = "Reentrancy"
    ORACLE_MANIPULATION = "Oracle Manipulation"
    FLASH_LOAN = "Flash Loan"
    SLIPPAGE = "Slippage/Price"
    PROXY = "Proxy"
    DOS_GAS = "Gas-based DoS"
    SIGNATURE = "Signature"
    ARITHMETIC = "Arithmetic"
    FRONT_RUNNING = "Front Running"


@dataclass
class Vulnerability:
    name: str
    category: VulnerabilityCategory
    description: str
    level: VulnerabilityLevel
    line_number: int
    code_snippet: str
    recommendation: str
    cwe_id: Optional[str] = None


@dataclass
class ScanResult:
    contract_address: str
    contract_name: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scan_time: float = 0.0
    lines_of_code: int = 0
    
    @property
    def is_safe(self) -> bool:
        return len([v for v in self.vulnerabilities if v.level in [VulnerabilityLevel.CRITICAL, VulnerabilityLevel.HIGH]]) == 0
    
    @property
    def critical_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.level == VulnerabilityLevel.CRITICAL])
    
    @property
    def high_count(self) -> int:
        return len([v for v in self.vulnerabilities if v.level == VulnerabilityLevel.HIGH])
    
    def get_by_category(self, category: VulnerabilityCategory) -> List[Vulnerability]:
        return [v for v in self.vulnerabilities if v.category == category]


class VulnerabilityScanner:
    """
    Comprehensive Smart Contract Vulnerability Scanner
    
    Detects:
    - Access Control Issues
    - Reentrancy
    - Oracle Manipulation
    - Flash Loan Design Flaws
    - Slippage/Price Errors
    - Proxy Initialization Issues
    - Gas-based DoS
    - Signature Issues
    - Arithmetic Overflows
    - Front-Running
    """
    
    VULNERABILITY_PATTERNS = {
        # ============================================
        # 1. ACCESS CONTROL ISSUES
        # ============================================
        "missing_owner_check": {
            "category": VulnerabilityCategory.ACCESS_CONTROL,
            "pattern": r"function\s+\w+\s*\([^)]*\)\s*public\s*\{(?!.*(?:require|if).*owner|.*onlyOwner)",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-862",
            "description": "Public function missing owner access control",
            "recommendation": "Add onlyOwner modifier or require(msg.sender == owner)"
        },
        "missing_role_check": {
            "category": VulnerabilityCategory.ACCESS_CONTROL,
            "pattern": r"function\s+\w+\s*\(.*\)\s*external\s*\{(?!.*hasRole|.*checkRole)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-862",
            "description": "Missing role-based access control",
            "recommendation": "Implement OpenZeppelin AccessControl or RoleBased"
        },
        "tx_origin_authorization": {
            "category": VulnerabilityCategory.ACCESS_CONTROL,
            "pattern": r"require\s*\(\s*tx\.origin\s*==",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-477",
            "description": "Using tx.origin for authorization (vulnerable to phishing)",
            "recommendation": "Use msg.sender instead of tx.origin"
        },
        "unprotected_selfdestruct": {
            "category": VulnerabilityCategory.ACCESS_CONTROL,
            "pattern": r"selfdestruct|suicide",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-451",
            "description": "Unprotected selfdestruct (can steal all funds)",
            "recommendation": "Add onlyOwner modifier to selfdestruct functions"
        },
        "unprotected_eth_withdrawal": {
            "category": VulnerabilityCategory.ACCESS_CONTROL,
            "pattern": r"payable\s*\(\s*address\s*\(\s*0\s*\)\s*\)\s*\.\s*transfer",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-451",
            "description": "Unprotected ETH withdrawal",
            "recommendation": "Add access control to withdrawal functions"
        },
        
        # ============================================
        # 2. REENTRANCY
        # ============================================
        "reentrancy_call": {
            "category": VulnerabilityCategory.REENTRANCY,
            "pattern": r"(?<!\w)(call|send|transfer)\s*\([^}]*\)",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-367",
            "description": "External call before state change (Reentrancy)",
            "recommendation": "Use checks-effects-interactions pattern or ReentrancyGuard"
        },
        "reentrancy_event": {
            "category": VulnerabilityCategory.REENTRANCY,
            "pattern": r"emit\s+\w+\s*\([^)]*\)\s*;(?:\s*\n\s*)?(?!\s*\})(?!\s*\{)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-367",
            "description": "Event emission before state changes",
            "recommendation": "Emit events after all state changes"
        },
        "missing_reentrancy_guard": {
            "category": VulnerabilityCategory.REENTRANCY,
            "pattern": r"function\s+\w+\s*\([^)]*\)\s*(?:external|public)\s*(?!.*nonReentrant)",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-367",
            "description": "Missing ReentrancyGuard on state-modifying function",
            "recommendation": "Add nonReentrant modifier from OpenZeppelin"
        },
        
        # ============================================
        # 3. ORACLE MANIPULATION
        # ============================================
        "oracle_manipulation_uniswap": {
            "category": VulnerabilityCategory.ORACLE_MANIPULATION,
            "pattern": r"getReserves\s*\(\s*\)|token0Reserves|token1Reserves",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-703",
            "description": "Using Uniswap V2 reserves as price oracle (manipulable)",
            "recommendation": "Use TWAP (Time-Weighted Average Price) or Chainlink"
        },
        "unprotected_dex_price": {
            "category": VulnerabilityCategory.ORACLE_MANIPULATION,
            "pattern": r"(?:quote|getAmountOut|getPrice)\s*\([^)]*\)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-703",
            "description": "Using DEX spot price as oracle (flash loan vulnerable)",
            "recommendation": "Use TWAP or external oracle like Chainlink"
        },
        "single_block_price": {
            "category": VulnerabilityCategory.ORACLE_MANIPULATION,
            "pattern": r"block\.timestamp\s*[<>=]+\s*.*|\.block\.number",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-382",
            "description": "Single block price check (manipulable in same block)",
            "recommendation": "Use time-averaged prices over multiple blocks"
        },
        
        # ============================================
        # 4. FLASH LOAN DESIGN FLAWS
        # ============================================
        "flash_loan_callback_no_validation": {
            "category": VulnerabilityCategory.FLASH_LOAN,
            "pattern": r"function\s+executeOperation\s*\([^)]*\)\s*(?!.*require.*pool)",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-345",
            "description": "Flash loan callback without proper validation",
            "recommendation": "Validate caller is actually the lending pool"
        },
        "flash_loan_sandwich": {
            "category": VulnerabilityCategory.FLASH_LOAN,
            "pattern": r"swapExactETHForTokens|swapExactTokensForETH",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-346",
            "description": "Single swap vulnerable to flash loan sandwich attack",
            "recommendation": "Use multi-step swaps or protected DEXes"
        },
        "no_flash_loan_protection": {
            "category": VulnerabilityCategory.FLASH_LOAN,
            "pattern": r"function\s+\w+\s*\([^)]*\)\s*external\s*\{(?!.*block\.number)",
            "level": VulnerabilityLevel.LOW,
            "cwe": "CWE-346",
            "description": "No protection against flash loan attacks",
            "recommendation": "Consider rate-limiting or multi-block requirements"
        },
        
        # ============================================
        # 5. SLIPPAGE / PRICE ERRORS
        # ============================================
        "no_slippage_protection": {
            "category": VulnerabilityCategory.SLIPPAGE,
            "pattern": r"swap(?:Exact|ExactETH|ExactTokens)\s*\w+\s*,\s*0[,\)]",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-366",
            "description": "Swap with zero minimum amount out (unlimited slippage)",
            "recommendation": "Always set amountOutMin to protect against slippage"
        },
        "hardcoded_slippage": {
            "category": VulnerabilityCategory.SLIPPAGE,
            "pattern": r"amountOutMin\s*=\s*\w+\s*\*\s*(?:95|97|99)\s*/\s*100",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-366",
            "description": "Hardcoded slippage tolerance (may be too low/high)",
            "recommendation": "Make slippage configurable per-trade"
        },
        "missing_slippage_check": {
            "category": VulnerabilityCategory.SLIPPAGE,
            "pattern": r"swap(?:Exact|ExactETH)\s*\w+\s*\)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-366",
            "description": "Swap without slippage protection",
            "recommendation": "Calculate and enforce minimum output amount"
        },
        
        # ============================================
        # 6. PROXY INITIALIZATION
        # ============================================
        "missing_initializer": {
            "category": VulnerabilityCategory.PROXY,
            "pattern": r"function\s+initialize\s*\([^)]*\)\s*(?!.*initializer)",
            "level": VulnerabilityLevel.CRITICAL,
            "cwe": "CWE-1041",
            "description": "Initializer function missing initializer modifier",
            "recommendation": "Add initializer modifier to prevent re-initialization"
        },
        "public_initializer": {
            "category": VulnerabilityCategory.PROXY,
            "pattern": r"function\s+init\s*\([^)]*\)\s*public",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-1041",
            "description": "Public initializer can be called by anyone",
            "recommendation": "Make initializer internal or add access control"
        },
        "uninitialized_proxy": {
            "category": VulnerabilityCategory.PROXY,
            "pattern": r"contract\s+\w+\s*is\s+.*Proxy",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-1041",
            "description": "Proxy contract - ensure proper initialization",
            "recommendation": "Call initializer in constructor or via proxy pattern"
        },
        
        # ============================================
        # 7. GAS-BASED DOS
        # ============================================
        "dos_loop_unbounded": {
            "category": VulnerabilityCategory.DOS_GAS,
            "pattern": r"for\s*\([^)]*;\s*\w+\s*<\s*(?:length|size|len)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-400",
            "description": "Unbounded loop can cause DoS via gas exhaustion",
            "recommendation": "Use pagination or chunking for large arrays"
        },
        "dos_external_call_in_loop": {
            "category": VulnerabilityCategory.DOS_GAS,
            "pattern": r"for\s*\([^)]*\)\s*\{[^}]*\.call\s*\(",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-400",
            "description": "External call in loop can cause DoS",
            "recommendation": "Move external calls outside loops when possible"
        },
        "dos_array_operations": {
            "category": VulnerabilityCategory.DOS_GAS,
            "pattern": r"(?:push|pop|delete)\s+\w+\s*\[\s*\w+\s*\]",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-400",
            "description": "Array operations can be expensive",
            "recommendation": "Consider using mappings instead of arrays"
        },
        "unlimited_gas": {
            "category": VulnerabilityCategory.DOS_GAS,
            "pattern": r"\.call\s*\(\s*[\"'][\"']\s*,\s*[\"'][\"']\s*\)",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-400",
            "description": "Unlimited gas forwarding to external call",
            "recommendation": "Specify gas limit explicitly"
        },
        
        # ============================================
        # 8. SIGNATURE ISSUES
        # ============================================
        "signature_replay": {
            "category": VulnerabilityCategory.SIGNATURE,
            "pattern": r"ecrecover\s*\([^)]*\)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-347",
            "description": "ecrecover without nonce replay protection",
            "recommendation": "Include chainId and nonce in signature"
        },
        "signature_malleability": {
            "category": VulnerabilityCategory.SIGNATURE,
            "pattern": r"\.slice\s*\(\s*0\s*,\s*32\s*\)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-347",
            "description": "Signature malleability - signatures can be replayed with different v value",
            "recommendation": "Use OpenZeppelin's SignatureChecker or EIP-712"
        },
        "missing_signature_validation": {
            "category": VulnerabilityCategory.SIGNATURE,
            "pattern": r"verify\s*\([^)]*\)\s*;(?!.*require)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-345",
            "description": "Signature verification result not checked",
            "recommendation": "Always require signature verification to pass"
        },
        "low_s_value": {
            "category": VulnerabilityCategory.SIGNATURE,
            "pattern": r"ecrecover",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-347",
            "description": "Missing check for low s-value (EIP-2)",
            "recommendation": "Require s <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0"
        },
        
        # ============================================
        # 9. ARITHMETIC ISSUES
        # ============================================
        "integer_overflow": {
            "category": VulnerabilityCategory.ARITHMETIC,
            "pattern": r"(?<!\w)(?:\+\+|\-\-|\+=|\-=|\*=|\/=)\s*[^;]+;",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-190",
            "description": "Potential integer overflow/underflow (< Solidity 0.8)",
            "recommendation": "Use Solidity 0.8+ or SafeMath library"
        },
        "unchecked_math": {
            "category": VulnerabilityCategory.ARITHMETIC,
            "pattern": r"(?:add|sub|mul|div)\s*\([^)]*\)\s*;(?!\s*require)",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-190",
            "description": "Arithmetic operation without overflow check",
            "recommendation": "Use SafeMath or Solidity 0.8+ with checked arithmetic"
        },
        "division_before_multiplication": {
            "category": VulnerabilityCategory.ARITHMETIC,
            "pattern": r"\w+\s*/\s*\w+\s*\*\s*\w+",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-190",
            "description": "Division before multiplication can cause precision loss",
            "recommendation": "Multiply before division when possible"
        },
        
        # ============================================
        # 10. FRONT-RUNNING
        # ============================================
        "front_running_sensitive": {
            "category": VulnerabilityCategory.FRONT_RUNNING,
            "pattern": r"require\s*\(\s*msg\.value\s*>=|require\s*\(\s*msg\.value\s*>",
            "level": VulnerabilityLevel.HIGH,
            "cwe": "CWE-346",
            "description": "Sensitive to front-running (same tx with higher gas)",
            "recommendation": "Use commit-reveal scheme or batch auctions"
        },
        "public_mempool_function": {
            "category": VulnerabilityCategory.FRONT_RUNNING,
            "pattern": r"function\s+(?:bid|buy|mint|stake)\s*\([^)]*\)\s*public",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-346",
            "description": "Public function that can be front-run",
            "recommendation": "Consider using batch auction or commit-reveal"
        },
        "sensitive_order": {
            "category": VulnerabilityCategory.FRONT_RUNNING,
            "pattern": r"setPrice|setFee|updateRatio",
            "level": VulnerabilityLevel.MEDIUM,
            "cwe": "CWE-346",
            "description": "Sensitive parameter update visible in mempool",
            "recommendation": "Use timelock or delayed execution"
        },
    }

    def __init__(self, web3=None):
        self.web3 = web3
        self.abi_cache: Dict[str, str] = {}
        
    async def scan_source_code(self, source_code: str, contract_name: str = "Unknown") -> ScanResult:
        """Comprehensive vulnerability scan of Solidity source code"""
        import time
        start_time = time.time()
        
        vulnerabilities = []
        lines = source_code.split('\n')
        
        # Check for Solidity version
        sol_version_vulns = self._check_solidity_version(lines)
        vulnerabilities.extend(sol_version_vulns)
        
        # Check each vulnerability pattern
        for vuln_name, vuln_info in self.VULNERABILITY_PATTERNS.items():
            pattern = vuln_info["pattern"]
            level = vuln_info["level"]
            category = vuln_info["category"]
            description = vuln_info["description"]
            recommendation = vuln_info["recommendation"]
            cwe = vuln_info.get("cwe")
            
            for line_num, line in enumerate(lines, 1):
                if re.search(pattern, line, re.MULTILINE | re.IGNORECASE):
                    if self._is_false_positive(vuln_name, line):
                        continue
                    vulnerabilities.append(Vulnerability(
                        name=vuln_name,
                        category=category,
                        description=description,
                        level=level,
                        line_number=line_num,
                        code_snippet=line.strip()[:100],
                        recommendation=recommendation,
                        cwe_id=cwe
                    ))
        
        scan_time = time.time() - start_time
        
        return ScanResult(
            contract_address="",
            contract_name=contract_name,
            vulnerabilities=vulnerabilities,
            scan_time=scan_time,
            lines_of_code=len(lines)
        )
    
    async def scan_bytecode_analysis(self, address: str) -> ScanResult:
        """Basic bytecode analysis for deployed contracts"""
        # Limited bytecode analysis
        return ScanResult(
            contract_address=address,
            contract_name="Bytecode Analysis",
            vulnerabilities=[]
        )
    
    def _is_false_positive(self, vuln_name: str, line: str) -> bool:
        """Filter false positives"""
        # Skip comments
        if line.strip().startswith("//"):
            return True
        # Skip events/emit
        if re.match(r"^\s*event\s+", line, re.IGNORECASE):
            return True
        # Skip require in reentrancy check
        if vuln_name == "reentrancy_call" and "require" in line:
            return True
        # Skip checked math
        if vuln_name == "integer_overflow" and ("require" in line or "assert" in line):
            return True
        return False
    
    def _check_solidity_version(self, lines: List[str]) -> List[Vulnerability]:
        """Check Solidity version vulnerabilities"""
        vulnerabilities = []
        for line_num, line in enumerate(lines, 1):
            if "pragma solidity" in line:
                # Very old versions
                if re.search(r"pragma\s+solidity\s+\^?0\.[0-4]\.", line, re.IGNORECASE):
                    vulnerabilities.append(Vulnerability(
                        name="very_old_solidity_version",
                        category=VulnerabilityCategory.ARITHMETIC,
                        description="Very old Solidity version (< 0.5) - multiple vulnerabilities",
                        level=VulnerabilityLevel.CRITICAL,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation="Upgrade to Solidity 0.8.0+",
                        cwe="CWE-937"
                    ))
                # Old versions without built-in overflow protection
                elif re.search(r"pragma\s+solidity\s+\^?0\.[5-7]\.", line, re.IGNORECASE):
                    vulnerabilities.append(Vulnerability(
                        name="old_solidity_version",
                        category=VulnerabilityCategory.ARITHMETIC,
                        description="Old Solidity version (0.5-0.7) - no built-in overflow protection",
                        level=VulnerabilityLevel.HIGH,
                        line_number=line_num,
                        code_snippet=line.strip(),
                        recommendation="Upgrade to Solidity 0.8.0+",
                        cwe="CWE-937"
                    ))
        return vulnerabilities
    
    def generate_report(self, result: ScanResult) -> str:
        """Generate detailed vulnerability report"""
        report = []
        report.append("=" * 70)
        report.append(f"ðŸ”’ SMART CONTRACT SECURITY SCAN REPORT")
        report.append("=" * 70)
        report.append(f"Contract: {result.contract_name}")
        report.append(f"Lines of Code: {result.lines_of_code}")
        report.append(f"Scan Time: {result.scan_time:.2f}s")
        report.append("")
        
        # Summary
        if result.is_safe:
            report.append("âœ… RESULT: NO CRITICAL/HIGH VULNERABILITIES")
        else:
            report.append(f"âš ï¸  VULNERABILITIES FOUND: {len(result.vulnerabilities)}")
            report.append(f"   ðŸ”´ Critical: {result.critical_count}")
            report.append(f"   ðŸŸ  High: {result.high_count}")
        report.append("")
        
        # Group by category
        for category in VulnerabilityCategory:
            vulns = result.get_by_category(category)
            if vulns:
                report.append(f"\n## {category.value} ({len(vulns)})")
                report.append("-" * 50)
                for vuln in vulns:
                    emoji = "ðŸ”´" if vuln.level == VulnerabilityLevel.CRITICAL else "ðŸŸ " if vuln.level == VulnerabilityLevel.HIGH else "ðŸŸ¡" if vuln.level == VulnerabilityLevel.MEDIUM else "ðŸŸ¢"
                    report.append(f"  {emoji} [{vuln.level.value}] Line {vuln.line_number}: {vuln.name}")
                    report.append(f"      {vuln.description}")
                    report.append(f"      Code: {vuln.code_snippet[:60]}...")
                    report.append(f"      Fix: {vuln.recommendation}")
                    if vuln.cwe_id:
                        report.append(f"      CWE: {vuln.cwe_id}")
                    report.append("")
        
        report.append("=" * 70)
        report.append("SCAN CATEGORIES COVERED:")
        for cat in VulnerabilityCategory:
            count = len(result.get_by_category(cat))
            status = "âœ…" if count == 0 else "âš ï¸"
            report.append(f"  {status} {cat.value}")
        
        return "\n".join(report)


class ContractSecurityValidator:
    """
    Validates contracts before trading - integrates with trading bot
    """
    def __init__(self, web3=None):
        self.scanner = VulnerabilityScanner(web3)
        self.whitelist: Dict[str, bool] = {}
        self.verified_contracts: set = set()
        
    async def validate_contract(self, address: str, source_code: str = None) -> Tuple[bool, ScanResult]:
        """Validate contract - returns (is_safe, scan_result)"""
        addr = address.lower()
        
        if addr in self.verified_contracts:
            return True, None
        if addr in self.whitelist and self.whitelist[addr]:
            return True, None
            
        result = await self.scanner.scan_source_code(source_code or "", contract_name=address)
        
        if result.is_safe:
            self.whitelist[addr] = True
            self.verified_contracts.add(addr)
            logger.info(f"âœ… Contract {address} validated - safe for trading")
            return True, result
            
        logger.warning(f"âš ï¸ Contract {address} has vulnerabilities: {result.critical_count} critical, {result.high_count} high")
        return False, result
    
    def is_approved(self, address: str) -> bool:
        return address.lower() in self.verified_contracts
    
    def add_to_whitelist(self, address: str):
        addr = address.lower()
        self.whitelist[addr] = True
        self.verified_contracts.add(addr)
    
    def remove_from_whitelist(self, address: str):
        addr = address.lower()
        self.whitelist[addr] = False
        self.verified_contracts.discard(addr)


class VulnerableContractLogger:
    """Logs vulnerable contracts but allows trading with caution"""
    
    def __init__(self):
        self.vulnerable_contracts: Dict[str, List[Vulnerability]] = {}
        self.trade_count = 0
        self.vulnerable_trade_count = 0
        
    def log_vulnerability(self, address: str, vulnerabilities: List[Vulnerability], trade_executed: bool):
        """Log contract vulnerabilities"""
        addr = address.lower()
        
        if addr not in self.vulnerable_contracts:
            self.vulnerable_contracts[addr] = vulnerabilities
            
        self.trade_count += 1
        if trade_executed:
            self.vulnerable_trade_count += 1
            
    def get_report(self) -> dict:
        """Get vulnerability report"""
        return {
            "total_trades": self.trade_count,
            "trades_with_vulnerable_contracts": self.vulnerable_trade_count,
            "vulnerable_contracts": {
                addr: [
                    {
                        "name": v.name,
                        "category": v.category.value,
                        "level": v.level.value,
                        "description": v.description,
                        "recommendation": v.recommendation
                    }
                    for v in vulns
                ]
                for addr, vulns in self.vulnerable_contracts.items()
            }
        }
    
    def get_risky_addresses(self) -> List[str]:
        """Get list of most risky addresses"""
        risky = []
        for addr, vulns in self.vulnerable_contracts.items():
            critical = len([v for v in vulns if v.level == VulnerabilityLevel.CRITICAL])
            high = len([v for v in vulns if v.level == VulnerabilityLevel.HIGH])
            score = critical * 10 + high
            if score > 0:
                risky.append((addr, score))
        return [addr for addr, _ in sorted(risky, key=lambda x: x[1], reverse=True)]
